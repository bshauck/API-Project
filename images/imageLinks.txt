Wireframe:
https://appacademy-open-assets.s3.us-west-1.amazonaws.com/Modular-Curriculum/content/week-16/AirBnB+MVP+Wireframes.pdf

SUNDAY1
added ErrorBoundary wrapper on top
LoginFormModal tweaks
Spot fill-ins for testing create more random
More error checking for SpotForm
Add progress cursor for all db access
Renewed actionList
Added all grading feedback to actionList
Documented new store layout in actionList

SUNDAY2
Renaming for consistent thunkiness
Converted Spots store functions to new approach

SUNDAY3
(convert rest of thunks)
put in app avoid multiple review reads
moved booking out until time to add it
made preview images more uniform starting size
Star icons now have default cursor
add reviews to spot state shape
set numReviews to 0 and avgRating to null
  and reviews to [] for new Spots
Add comments in all store files for
  transition to new store shape


SUNDAY4


MVP BUGS
CRITICAL
1. Unable to create a review on a new spot.
2. Unable to update a spot
MEDIUM
1. Sign up button doesn't handle valid email validation ..._sign_up_button_closes_and_no_validation_shown
2. The single spot page seems to break when a sign up is not successful single_spot_breaks_when_signup_is_not_successful
3. Average star rating on the home/spot details page does not match the one on the manage spots page. All of them seem to be new
4.When looking at a site with no reviews, the number of requests seems to go up with no stop _no_reviews_result_on_an_infinite_amount_of_requests
LOW
1. Sometimes going from the manage spots page to the home page results in a bug going_from_the_manage_spots_to_the_home_page_sometimes_results_in_a_bug

SPECS NOT passing
AUTHME
When clicking "Sign up" button on the new user account form with errors in the form, it must show all error messages returned from the backend (similar to the following): "The provided email is invalid" or "Username must be unique".
APPLICATION
NOT UP TO Wireframe
  Landing page --The css does not fully match what's expected from the wireframes. An example is the gap between each spot.
  Spot Details --Css does not match the wireframes https://jeffbnb.s3.us-east-2.amazonaws.com/Grading/Jun23/William/Shauck_William_callout_box_on_the_left.png
  View Rating and Reviews --1 reviews is shown https://jeffbnb.s3.us-east-2.amazonaws.com/Grading/Jun23/William/Shauck_William_reviews_is_shown_instead_of_review.png
  Post Review --Css does not match the wireframes.
  Manage Spots --Css does not fully match the wireframes.
  Delete a Review --Css does not match the wireframes.
The callout information box on the right of the spot's detail page should state the price for the spot followed by the label "night", and have a "Reserve" button.
  Callout box is not located on the right side
If no reviews have been posted yet and the current user is logged-in and is NOT the owner of the spot, replace the reviews list with the text "Be the first to post a review!"
  _not_be_the_first_to_post_a_review_text.png
If the current user is logged-in and they are viewing a spot's detail page for a spot that they HAVE NOT posted a review yet, a "Post Your Review" button shows between the rating/reviews heading and the list of reviews.
  In new spots this button does not show.
The spot management page should contain a spot tile list similar to the one in the landing page (thumbnail image, location, rating, price).
  Rating on the manage page does not match what is actually on the db.
When the update form submission is successful, the user is navigated to the updated spot's details page.
  Update does not seem to work.
The updated spot's detail page should display the updated information. No refresh should be necessary.
  Update does not seem to work.





ISSUES
Passing certain db errors like signup uniqueness for email/username back up.
Figure out default image sizes and layout
Adding Callout with price night, small review avg, Reserve button
StarRatings add to SpotDetails' callout box
Ensure spot delete updates landing pages/manage spot pages
Use placeholders when users have not contributed enough images
Have SpotForm show first 4 validation error messages to side of label
Comma misplaced on Create Spot (city, state)
Add buttons to page through more spots than default page size
Change default page size back to 20 (from 50), and track how you do
  listing of landing spots, and maintain that, and know page being
  displayed through renders


Subheading size too large
Subheading weight too heavy
Regular text too large
Heading weight somewhat more
Textarea needs to extend across
L/R edges of most elements need to align
Submit button needs to be centered and colored
Remove DEFAULT button (LAST THING)
Confirm spot image creation working NO
Have reasonable image sizing (tiles should be 3x6)
CSS Delete Spot modal
CSS not-logged-in menu
CSS sign up dialog form

Adding Fake descriptive text for host
Adding divider on Spot details

Understanding entire flow of error-handling and implementing correctly
from front request with thunk to thunk fetch (I understand backend, and
csrfFetch checking status code and throwing error when code >= 400) (decoration
suggested removing the csrfFetch throw, just checking the error code, using
async/await; changed login modal handling but need to do that for signup;
long term do better with then.catch consistency)
If we do throws from thunk then all app code has to have catch and handle throws;
instead we do returns from thunk and only check for thing.errors.

Better understanding of Promise .then.catch
Knowing when things may be promises; and why some things that are
    Promises are sometimes, are also not sometimes
    e.g., response from fetch does not always understand .JSON


FINALLY CSS
Form placeholder text lighter
price "night", star rating "review" both darker
Generate better, larger amount of data

BUGS:
Login on error (invalid password/credential) changes size,
and a sliver of a modalDiv appears underneath main modal


Bonus:
review update
Bookings
map API
after map API add read-only lat/long to SpotForm
store shape efficiency
caching
validate images
query search to change what spots are listed

Achieved:


Longterm:
Have previewUrl stored in Spot
Remove preview column from Spot Images table
SpotImages are only support images;
Update Spot has to do more work if
  updating existing images to different opens
  the previewUrl just stored in Spot,
  but the supporting ones being changed means
  have to look at differences and figure
  out what are insertions, and what are updates
  into the SpotImages table.
Dan says 100-1000 generated seeds
Look up all unseed functions via known userSpots
Restore query size default to 20 (set to 50 for
  dev atm)





new STORE layout
{
  session:
  users:
  spots:
  reviews:
  bookings:
  spotImages:
  reviewImages:
},

{ /* session */
  currentUser: user || null
}

/* users */
{
  [userId]:
    {
      id,
      firstName,
      lastName,

      // additional detail on login
      email,
      username,
      createdAt,  /// TODO?
      updatedAt   /// TODO?

      // additional detail if asked for current spots/review/bookings
      "spots": [spotIdArray],
      "reviews": [reviewIdArray],
      "bookings": [bookingIdArray]
    }
}

/* spots */
{
  [spotId]:
    {
      "id": 1,
      "ownerId": 1,
      "address": "123 Disney Lane",
      "city": "San Francisco",
      "state": "California",
      "country": "United States",
      "lat": 37.7645358,
      "lng": -122.4730327,
      "name": "App Academy",
      "description": "Place where web developers are created",
      "price": 123,
      "createdAt": "2021-11-19 20:39:36",
      "updatedAt": "2021-11-19 20:39:36",
      "numReviews": 4,
      "avgRating": 4.5,
      "previewUrl": "image url",

      // additional info; Details page gets images & reviews
      // reserve button gets bookings
      "images": [spotImageIdArray],
      "reviews": [reviewIdArray],
      "bookings": [bookingIdArray], // perhaps only ids whose endDate is in the future
    }
  "list": [orderedIdArrayBySomeInterestingCriteriaFromQuery]
}

/* reviews */
{
  [reviewId]:
    {
      id,
      userId,
      spotId,
      commentary, // renamed review column
      stars, // 1-5

      // additional details
      images: [reviewImageIdArray]
    },
  "list": [idsOrderedByDescUpdatedDate]
}

/* bookings */
{
  [bookingId]:
    {
      id,
      userId,
      spotId,
      startDate,
      endDate,
      createdAt,
      updatedAt
    },
  "list": [idsOrderedByAscFutureEndDatePerhaps]
}

/* spotImages */ /* once previewUrl in spot, no need to have preview column */
{
  [imageId]:
    {
      id,
      spotId,
      url
    }
}

/* reviewImages */
{
  [imageId]:
    {
      id,
      reviewId,
      url
    }
}


Ensure app runs in dev mode. Then try the following.

See if this article allows for configureStore change (v18)
  https://stackoverflow.com/questions/72479800/createstore-is-deprecated-so-im-trying-to-replace-with-configurationstore

Revisit backend; ensure all error code consistent
  API returns documented valid result or
  error object shape.

Ensure all db error responses for Auth Me are
  returned

Decide on backend to best support Redux shape
  (leave original API other than error code mess,
  add new API for better support if needed)

Dry backend (have a booking function duplicated)



Consistent error handling:

/* change fetch code back to throwing errors perhaps */
csrfFetch(‘https://example.com/data’)

fetch(url)
.then(response => response.ok ? response.json() : Promise.reject(response))
.then(json => doStuff(json)) //all good
.catch(response => handleError(response)) //handle error

I think with this last one we either do a dispatch(actionCreatorMethod(json/data)) in the 2nd .then,
or we ensure the right error format in the .catch and just do a return of that error; then
the app can look at the return and see if it has .errors and if so display them or ignore them as
appropriate. (and put the throw of an error back in the csrfFetch; which, if invoked, goes to the .catch).

const res = await fetch(url, opts).then(r => r.clone().json().catch(() => r.text()));
The above uses clone to do both a .json and a .text on the response body

Still a bit unsure about handling errors when the body wasn't packed with json, or
when the system error(s) hit. Probably need to look at headers for content-type, or
do the .clone and wrap a try in a catch that redoes with res.text() or some such.


Still need to do more testing for Network errors, but the following seems pretty good:
This assumes that error responses will either have a top-level "errors" key, or a
top-level "message" key. (If normal responses can have these, then special checking
will have to happen.) I'm not 100% sure I need the useless .then on !response.ok.

/* put this in csrf file, or separate and import if multi-thunk files */
/* silly ()s necessary in .catch avoiding parser confusion */
export function fetchData(url, options) {
  /* Returns Promise which resolves to either data or errors */
  return csrfFetch(url, options)
    .then(response => response.ok
        ? response.json()
        : response.json().then(err => err)) /* get detailed error info  */
    .catch(systemicError => ({"errors": {"system": systemicError.message}}))
}
export const jsonHeaderContent = {"Content-Type":"application/json"}

/* copy this boilerplate for each thunkFunc */
export const thunkFunc = (args) => async dispatch => {
    /* adjust url and option args as needed; skip options on GET */
    const url = `/api/resources`
    const options = {
      method: "POST",
      headers: jsonHeaderContent,
      body: JSON.stringify(/*args-ish*/)
    }
    const answer = await fetchData(url, options)
    /* if normal response can have errors or message keys, adjust check */
    /* change name of the actionCreator function to invoke, and possibly args */
    if (!answer.errors) dispatch(appropriateActionCreator(answer))
    /* else console.error(answer.errors || answer.message) */
    return answer /* short-circuits store and allows app code to directly get errors */
}  /* for display; so probably "wrong" in the sense of one-way Redux flow */

In application code, when you don't care about a return value (e.g., something
you need to use hasn't been loaded into the store yet), you can just do
dispatch(thunkFunc(anyArgs));
So in application code, do const result = await dispatch(thunkFunc(anyArgs));
Then error check if needed to display errors. (Possibly handle all in .then()
rather than await: e.g. .then(answer => answer.errors
? setValidations(answer.errors) : setReport(answer)))



===================
In a component that needs details that will be fetched
only for this component, a way to avoid additional
fetch requests is to know a previous request has been
made by keeping track of it.

  // 11 lines avoiding 2nd reqs can be narrowed to 9 if dispatch(thunk)
  // return value
  const ref = useRef([]);
  if (thing.id) { // have top level, check for inner need
    if (!thing.inner) { // missing inner details
      if (!ref.current[thing.id]) { // first request
        ref.current[thing.id] = true;
        dispatch(thunkGetThingDetails(thing.id))
      }
      return null; // no details yet; but need them
    } else if (ref.current[thing.id]) // fulfilled; remove
      delete ref.current[thing.id]
  }



Add ErrorBoundaries around components to limit error impact

import React from "react";

class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null, info: null}

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, info) {
    this.setState({this.hasError, error, info})
    console.error(error, info);
  }

  render() {
    return this.state.hasError ? (
      <div><h1>Something went wrong.</h1>
        {process.env.NODE_ENV !== 'production' && (
          <details style={{ whiteSpace: 'pre-wrap' }}>
            <summary>Click for error details</summary>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.info && this.state.info.componentStack}
          </details>
        )}
      </div>
    ) : this.props.children
}

export default ErrorBoundary
