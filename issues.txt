


ISSUES
Figure out default image sizes and layout
Use placeholders when users have not contributed enough images
Have SpotForm show first 4 validation error messages to side of label
Comma misplaced on Create Spot (city, state)
Add buttons to page through more spots than default page size
Change default page size back to 20 (from 50), and track how you do
  listing of landing spots, and maintain that, and know page being
  displayed through renders


Subheading size too large
Subheading weight too heavy
Regular text too large
Heading weight somewhat more
Textarea needs to extend across
L/R edges of most elements need to align
Submit button needs to be centered and colored
Remove DEFAULT button (LAST THING)
Confirm spot image creation working NO
Have reasonable image sizing (tiles should be 3x6)
CSS Delete Spot modal
CSS not-logged-in menu
CSS sign up dialog form

Adding Fake descriptive text for host
Adding divider on Spot details

Understanding entire flow of error-handling and implementing correctly
from front request with thunk to thunk fetch (I understand backend, and
csrfFetch checking status code and throwing error when code >= 400) (decoration
suggested removing the csrfFetch throw, just checking the error code, using
async/await; changed login modal handling but need to do that for signup;
long term do better with then.catch consistency)
If we do throws from thunk then all app code has to have catch and handle throws;
instead we do returns from thunk and only check for thing.errors.

Better understanding of Promise .then.catch
Knowing when things may be promises; and why some things that are
    Promises are sometimes, are also not sometimes
    e.g., response from fetch does not always understand .JSON


FINALLY CSS
Form placeholder text lighter
price "night", star rating "review" both darker
Generate better, larger amount of data

BUGS:
Login on error (invalid password/credential) changes size,
and a sliver of a modalDiv appears underneath main modal

LONGTERM
Figure out DB table constraints syntax for Sequelize for Sqlite3 & PostGreSQL (probably have to be literal SQL), and implementing
appropriate table constraints which match application constraints where possible and put into migration files (better protection against bad seeding; although may make historical seeding hard; so may have to skip date checking)
Put console logs at beginning of all component functions and just before
return statements, and check that ACTUAL re-rendering is minimal.
Use db transactions to rollback multi-table changes when errors occur after 1st table succeeds
Switch to RTK and RTK Query
Switch to Vite instead of CRA
Change all READ items to GOT (past of GET)
Make names more explicit (no "plain" ids)
Figure out Render transfer approach
